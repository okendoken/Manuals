<!doctype html>  

<!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ --> 
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]>    <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html lang="be-tarask" class="no-js"> <!--<![endif]-->
<head>
  <meta charset="utf-8">

  <!-- Always force latest IE rendering engine (even in intranet) & Chrome Frame 
       Remove this if you use the .htaccess -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <title>Тэхнічны даведнік па Ruby</title>
  <meta name="description" content="Тэхнічны даведнік па Ruby">
  <meta name="author" content="Юрцэвіч Дзьмітры">

  <!--  Mobile viewport optimized: j.mp/bplateviewport -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Place favicon.ico & apple-touch-icon.png in the root of your domain and delete these references -->
  <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">
  <link rel="apple-touch-icon" href="../apple-touch-icon.png">


  <!-- CSS : implied media="all" -->
  <link rel="stylesheet" href="../css/boilerplate.css?v=2">
  <link rel="stylesheet" href="../css/style.css?v=1">
  <link rel="stylesheet" href="../css/mktree.css?v=1">
  <link rel="stylesheet" href="../css/shCore.css?v=1">
  <link rel="stylesheet" href="../css/shThemeRDark.css?v=1">

  <!-- Uncomment if you are specifically targeting less enabled mobile browsers
  <link rel="stylesheet" media="handheld" href="css/handheld.css?v=2">  -->
 
  <!-- All JavaScript at the bottom, except for Modernizr which enables HTML5 elements & feature detects -->
  <script src="../js/libs/modernizr-1.6.min.js"></script>
  
  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
</head>

<body>

  <div id="container">
    <div id="index">
      <div id="main_index">
        <ul>
          <li><a href="../htmlRef/index.html">HTML</a></li>
          <li><a href="../cssRef/index.html">CSS</a></li>
          <li><a href="../jsRef/index.html">JS</a></li>
          <li><a href="../webRef/index.html">Web</a></li>
        </ul>
        <ul>
          <li><a href="../javaRef/index.html">Java</a></li>
        </ul>
        <ul>
          <li><a href="../rubyRef/index.html">Ruby</a></li>
          <li><a href="../railsRef/index.html">Rails</a></li>
        </ul>
        <ul>
          <li><a href="../gitRef/index.html">Git</a></li>
        </ul>
      </div>

      <div id="content">
        <ul class="mktree">
          <li><a href="#Links">Карысныя спасылкі</a>
            <ul>
              <li><a href="#Links_home">Хатняя старонка</a></li>
              <li><a href="#Links_docs">Дакумэнтацыя</a></li>
              <li><a href="#Links_api">API</a></li>
              <li><a href="#Links_refs">Даведнікі і кнігі</a>
                <ul>
                  <li><a href="#Links_refs_beginners">Пачаткоўцам</a></li>
                  <li><a href="#Links_refs_intermediate">Адмыслоўцам</a></li>
                </ul>
              </li>
              <li><a href="#Links_gems">Gems</a></li>
            </ul>
          </li>
          <li><a href="#Intro">Што такое Ruby?</a>
            <ul>
              <li><a href="#Intro_OOP">Аб&#39;ектна-арыентаваная мова</a></li>
              <li><a href="#Intro_IntuitiveNotation">Інтуітыўная натацыя</a></li>
            </ul>
          </li>
          <li><a href="#LangParts">Часткі мовы</a>
            <ul>
              <li><a href="#LangParts_Variables">Пераменныя</a></li>
              <li><a href="#LangParts_Symbols">Сымбалі</a></li>
              <li><a href="#LangParts_Consts">Канстанты</a></li>
              <li><a href="#LangParts_InstanceVar">Пераменныя экзэмпляраў</a></li>
              <li><a href="#LangParts_ClassVar">Пераменныя клясаў</a></li>
              <li><a href="#LangParts_GlobalVar">Глябальныя пераменныя</a></li>
              <li><a href="#LangParts_Methods">Мэтады</a>
                <ul>
                  <li><a href="#LangParts_Methods_redo">redo</a></li>
                </ul>
              </li>
              <li><a href="#LangParts_MethodArguments">Аргумэнты мэтадаў</a></li>
              <li><a href="#LangParts_ClassMethods">Мэтады клясаў</a></li>
              <li><a href="#LangParts_Blocks">Блёкі</a></li>
              <li><a href="#LangParts_BlockArguments">Аргумэнты блёкаў</a></li>
              <li><a href="#LangParts_Ranges">Дыяпазоны</a></li>
              <li><a href="#LangParts_Arrays">Масівы</a></li>
              <li><a href="#LangParts_Hashes">Хэшы</a></li>
              <li><a href="#LangParts_RegExp">Рэгулярныя выразы</a></li>
              <li><a href="#LangParts_Operators">Апэратары</a></li>
              <li><a href="#LangParts_Keywords">Ключавыя словы</a></li>
            </ul>
          </li>
          <li class="liOpen"><a href="#Types">Стандартныя тыпы</a>
            <ul>
              <li class="liOpen"><a href="#Types_Object">Object</a>
                <ul>
                  <li><a href="#Types_Object_Methods">Мэтады</a>
                    <ul>
                      <li><a href="#Types_Object_Methods_ID">Вызначэньне ID</a></li>
                      <li><a href="#Types_Object_Methods_Class">Вызначэньне клясы</a></li>
                      <li><a href="#Types_Object_Methods_InstanceOf">Прыналежнасьць да клясаў</a></li>
                      <li><a href="#Types_Object_Methods_Compare">Апэрацыі параўнаньня</a></li>
                      <li><a href="#Types_Object_Methods_nil">Праверка на <code class="keyword">nil</code></a></li>
                      <li><a href="#Types_Object_Methods_Clone">Кланаваньне</a></li>
                      <li><a href="#Types_Object_Methods_Freeze">Замарозка</a></li>
                      <li><a href="#Types_Object_Methods_StrRepr">Радковае прадстаўленьне</a></li>
                      <li><a href="#Types_Object_Methods_ClassStructure">Інспэкцыя структуры клясы</a></li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li class="liOpen"><a href="#Types_Numbers">Лікі</a>
                <ul>
                  <li><a href="#Types_Numbers_Integers">Цэлыя</a></li>
                  <li><a href="#Types_Numbers_Float">Рэчаісныя</a></li>
                  <li><a href="#Types_Numbers_Methods">Мэтады</a>
                    <ul>
                      <li><a href="#Types_Numbers_Methods_Math">Матэматычныя апэрацыі</a></li>
                      <li><a href="#Types_Numbers_Methods_Binary">Бінарныя апэрацыі</a></li>
                      <li><a href="#Types_Numbers_Methods_Compare">Апэрацыі параўнаньня</a></li>
                      <li><a href="#Types_Numbers_Methods_CriteriaCheck">Адпавяданьне пэўнаму крытэру</a></li>
                      <li><a href="#Types_Numbers_Methods_NumberTransform">Лікавыя трасфармацыі</a></li>
                      <li><a href="#Types_Numbers_Methods_Iterators">Ітэратары</a></li>
                      <li><a href="#Types_Numbers_Methods_TypeTransform">Трасфармацыі у іншыя тыпы</a></li>
                      <li><a href="#Types_Numbers_Methods_DivideModulo">Дзяленьне і вызначэньне астачы</a></li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li class="liOpen"><a href="#Types_Enumerable">Пералічэньне</a>
                <!--ul>
                  <li><a href="#Types_Strings_Methods">Мэтады</a>
                    <ul>
                      <li><a href="#Types_Strings_Methods_Size">Памер радка</a></li>
                      <li><a href="#Types_Strings_Methods_Compare">Параўнаньне радкоў</a></li>
                      <li><a href="#Types_Strings_Methods_Array">Паэлемэнтны доступ</a></li>
                      <li><a href="#Types_Strings_Methods_ContentTransforms">Мадыфікацыя зьместу</a></li>
                      <li><a href="#Types_Strings_Methods_CaseTransforms">Мадыфікацыя рэгістру літар</a></li>
                      <li><a href="#Types_Strings_Methods_Rundown">Паэлемэнтны перабор</a></li>
                      <li><a href="#Types_Strings_Methods_Analysis">Разбор радка</a></li>
                      <li><a href="#Types_Strings_Methods_Encoding">Кадоўка знакаў</a></li>
                      <li><a href="#Types_Strings_Methods_TypeTransforms">Трансфармацыя ў іншыя тыпы</a></li>
                    </ul>
                  </li>
                </ul-->
              </li>
              <li class="liOpen"><a href="#Types_Strings">Радкі</a>
                <ul>
                  <li><a href="#Types_Strings_Methods">Мэтады</a>
                    <ul>
                      <li><a href="#Types_Strings_Methods_Size">Памер радка</a></li>
                      <li><a href="#Types_Strings_Methods_Compare">Параўнаньне радкоў</a></li>
                      <li><a href="#Types_Strings_Methods_Array">Паэлемэнтны доступ</a></li>
                      <li><a href="#Types_Strings_Methods_ContentTransforms">Мадыфікацыя зьместу</a></li>
                      <li><a href="#Types_Strings_Methods_CaseTransforms">Мадыфікацыя рэгістру літар</a></li>
                      <li><a href="#Types_Strings_Methods_Rundown">Паэлемэнтны перабор</a></li>
                      <li><a href="#Types_Strings_Methods_Analysis">Разбор радка</a></li>
                      <li><a href="#Types_Strings_Methods_Encoding">Кадоўка знакаў</a></li>
                      <li><a href="#Types_Strings_Methods_TypeTransforms">Трансфармацыя ў іншыя тыпы</a></li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li class="liOpen"><a href="#Types_Ranges">Дыяпазоны</a>
                <ul>
                  <li><a href="#Types_Ranges_AsSequences">Як пасьлядоўнасьці</a></li>
                  <li><a href="#Types_Ranges_AsConditions">Як умовы</a></li>
                  <li><a href="#Types_Ranges_AsIntervals">Як інтэрвалы</a></li>
                  <li><a href="#Types_Ranges_Methods">Мэтады</a></li>
                </ul>
              </li>
              <li class="liOpen"><a href="#Types_Arrays">Масівы</a>
                <!--ul>
                  <li><a href="#Types_Ranges_AsSequences">Як пасьлядоўнасьці</a></li>
                </ul-->
              </li>
              <li class="liOpen"><a href="#Types_Hashes">Хэшы</a>
                <!--ul>
                  <li><a href="#Types_Ranges_AsSequences">Як пасьлядоўнасьці</a></li>
                </ul-->
              </li>
              <li class="liOpen"><a href="#Types_Regexp">Рэгулярныя выразы</a>
                <!--ul>
                  <li><a href="#Types_Ranges_AsSequences">Як пасьлядоўнасьці</a></li>
                </ul-->
              </li>
            </ul>
          </li>
          <li class="liOpen"><a href="#Gems">Gems</a>
            <ul>
              <li><a href="#Gems_DevKit">DevKit</a>
                <ul>
                  <li><a href="#Gems_DevKit_install">Усталёўка</a></li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </div>
    </div>
    
    <article id="main">
      <header>
        Даведнік па Ruby
      </header>

      <section>
        <p class="intro">Гэты даведнік зьяўляецца суб&#39;ектыўнай кампіляцыяй розных матэрыялаў па інтэрпрэтуемай, аб&#39;ектна-арыентаванай мове праграмаваньня <i>Ruby</i>. Структура і аб&#39;ём пададзенай тут інфармацыі былі выбраны ў адпаведнасьці з асабістымі патрэбамі аўтара і могуць не адпавядаць вашым патрэбам. Таксама аўтар не прэтэндуе на абсалютную дакладнасьць, паўнату ці зручнасьць пададзенай тут інфармацыі, і, адпаведна, не можа несьці адказнасьці за магчымыя негатыўныя наступствы ад любога выкарыстаньня гэтай інфармацыі.</p>
        <p class="intro">Пры выяўленьні памылак, недакладнасьцей альбо пры наяўнасьці пажаданьняў нешта дадаць ці палепшыць зьвяртайцеся, калі ласка, праз форму зваротнай сувязі (статычная кнопка Feedback у правым баку экрана). Не абяцаю, што зраблю ўсё, што будзе запытана, але абяцаю, што кожны запыт будзе мной разгледжаны.</p>

        <aside class="warn">Дадзены даведнік разглядае працу з <i>Ruby</i> вэрсіі <code>1.9.2</code> у <i>Windows</i>-асяродку. Будзьце ўважлівы!</aside>

        <h1><a name="Links">Карысныя спасылкі</a></h1>
        <h2><a name="Links_home">Хатняя старонка</a></h2>
        <p><a href="http://www.ruby-lang.org/">http://www.ruby-lang.org</a></p>
        
        <h2><a name="Links_docs">Дакумэнтацыя</a></h2>
        <p><a href="http://ruby-doc.org/">http://ruby-doc.org</a>&nbsp;&mdash; афіцыйная старонка, на якой сабраныя спасылкі да рознага кшталту дакумэнтацыі і літаратуры.</p>
        
        <h2><a name="Links_api">API</a></h2>
        <p>Ядро мовы: <a href="http://ruby-doc.org/ruby-1.9/index.html">http://ruby-doc.org/ruby-1.9/index.html</a></p>
        <p>Стандартныя бібліятэкі (StdLib):
          <ul>
            <li><a href="http://www.rubydoc.info/stdlib/">http://www.rubydoc.info/stdlib</a></li>
            <li><a href="http://www.ruby-doc.org/stdlib/">http://www.ruby-doc.org/stdlib</a></li>
          </ul> 
        </p>
        <p>Ruby + Rails (вельмі добра рэалізаваны пошук): <a href="http://railsapi.com/doc/rails-v3.0.1_ruby-v1.9.2/">http://railsapi.com/doc/rails-v3.0.1_ruby-v1.9.2</a></p>
        
        <h2><a name="Links_refs">Даведнікі і кнігі</a></h2>
        <h3><a name="Links_refs_beginners">Пачаткоўцам</a></h3>
        <p><a href="http://www.rubyist.net/~slagell/ruby/">Ruby user's guide</a></p>
        <p><a href="http://rubylearning.com/satishtalim/tutorial.html">Core Ruby Programming</a></p>
        <p><a href="http://mislav.uniqpath.com/poignant-guide/">Poignant-guide</a>&nbsp;&mdash; сьцёбны, арыгінальны, але прыдатны толькі для першапачатковага паглыбленьня ў мову вучэбнік.</p>
        
        <h3><a name="Links_refs_intermediate">Адмыслоўцам</a></h3>
        <p><a href="http://www.ruby-doc.org/docs/ProgrammingRuby/">Programming Ruby</a>&nbsp;&mdash; электронны варыянт першага выданьня адпаведнай кнігі ад <a href="http://pragprog.com/">The Pragmatic Programmers</a>.</p>
        <p><a href="http://en.wikibooks.org/wiki/Ruby_programming_language/">Ruby Programming Wiki-book</a> (расейскамоўны варыянт кнігі, на жаль, значна горшы).</p>
        
        <h2><a name="Links_gems">Gems</a></h2>
        <p>Хатняя старонка: <a href="http://rubygems.org/">http://rubygems.org</a></p>
        <p>Як шукаць і ўсталёўваць бібліятэкі: <a href="http://www.ruby-lang.org/en/libraries/">http://www.ruby-lang.org/en/libraries</a></p>
        <p>Bundler: <a href="http://gembundler.com/">http://gembundler.com</a></p>
        <br />
        <br />
        <br />
        <br />
        <p><a href="http://www.techotopia.com/index.php/Ruby_Essentials/">Ruby Essentials</a></p>
        <p><a href="http://rubyclub.com.ua/">Ruby Club</a></p>
      </section>

      <section>
        <h1><a name="Intro">Што такое Ruby?</a></h1>
        
        <h2><a name="Intro_OOP">Аб&#39;ектна-арыентаваная мова</a></h2>
        <p>Ruby зьяўляецца цалкам аб&#39;ектна-арыентаванай мовай праграмаваньня ў клясычным выглядзе. Усё, чым апэрыруе праграма на Ruby, зьяўляецца аб&#39;ектам, і вынікі гэтых апэрацый таксама зьяўляюцца аб&#39;ектамі. Аб&#39;ектна-арыентаванае праграмаваньне характаразуецца тым, што распрацоўшчык спрабуе смадэляваць аб&#39;ект рэальнага сьвету (возьмем у прыклад песьню) ў кодзе. У Ruby гэтыя аб&#39;екты прадстаўляюцца клясамі. Клясы ўяўляюць зь сябе камбінацыю з стану (напр., назва песьні) і мэтадаў, каторыя апэрыруюць гэтым станам (напр., мэтад, каторы прайграе песьню).</p>
        <p>Калі аб&#39;ект смадэляваны і адпаведная кляса напісаная, можна ствараць экзэмпляры гэтай клясы. Гэта адбываецца праз выклік канструктара&nbsp;&mdash; адмысловага мэтаду клясы, каторы звычайна называецца <code class="keyword">new</code>.</p>        
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        song1 = Song.new("Ruby Tuesday")
        song2 = Song.new("Enveloped in Python")
        ]]></script>
        <p>Абедзьве пераменныя <code class="local_var">song1</code> і <code class="local_var">song2</code> зьяўляюцца экзэплярамі адной і той жа клясы <code class="class">Song</code>, але маюць унікальныя характарыстыкі. Па-першае, кожны аб&#39;ект (экзэмпляр нейкай клясы) у Ruby мае ўнікальны ідэнтыфікатар (<i>object id</i>). Па-другое, кляса можа ўтрымліваць пераменныя экзэмпляру, каторыя будуць утрымліваць унікальныя для кожнага экзэмпляру значэньні. Гэтыя пераменныя і выражаюць пазначаны вышэй <i>стан</i> аб&#39;екта. Напрыклад, кляса <code class="class">Song</code> можа ўтрымліваць пераменную, якая захоўвае назву песьні.</p>
        <p>Акрамя гэтага кожная кляса можа вызначаць мэтады экзэмпляраў&nbsp;&mdash; пэўны функцыянал, каторы можа выклікацца як знутры клясы, так і, пры пэўных акалічнасьцях,&nbsp;&mdash; звонку. Гэтыя мэтады маюць доступ да пераменных экзэмпляраў і могуць маніпуляваць імі. Мэтады могуць таксама называцца паведамленьнямі ці запытамі да аб&#39;екта.</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        "gin joint".length      #=> 9
        "Rick".index("c")       #=> 2
        -1942.abs               #=> 1942
        sam.play(aSong)         #=> "duh dum, da dum de dum ..."
        ]]></script>
        <p>Тое, што стаіць да кропкі, называецца <i>атрымальнікам</i> паведамленьня/запыту. Пасьля кропкі ідзе мэтад, каторы павінен быць выкліканы. Першы з прыкладаў вышэй пытаецца пра дліну (мэтад <code class="method">length</code>) радка (<code>"gin joint"</code>). У другім прыкладзе ў іншага радка пытаецца пра індэкс літары <code>"c"</code> у ім. У трэцім прыкладзе мы пытаемся ў лічбы пра яе абсалютнае значэньне, а ў чацьвёртым просім <code>sam</code>&#39;а, каб ён прапеў (мэтад <code class="method">play</code>) нам песьню (перададзены ў якасьці парамэтру аб&#39;ект <code class="local_var">aSong</code>).</p>
        
        <h2><a name="Intro_IntuitiveNotation">Інтуітыўная натацыя</a></h2>
        <p>Ruby створаны такім чынам, каб код, напісаны на ім, быў інтуітыўна зразумелы. Напрыклад, наступны выраз:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        5.times { print "Odelay!" }
        ]]></script>
        <p>азначае &laquo;пяць (<code>5</code>) разоў (анг. <code class="method">times</code>) надрукуй (анг. <code class="method">print</code>) "Odelay!"&raquo;. А выраз:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        exit unless "restaurant".include? "aura"
        ]]></script>
        <p>азначае, што &laquo;праграмма павінна скончыць сваё дзеяньне (анг. <code class="method">exit</code>), калі радок "restaurant" не (анг. <code class="keyword">unless</code>) утрымлівае (анг. <code class="method">include</code>) радок "aura"&raquo;. А выраз:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        ['toast', 'cheese', 'wine'].each { |food| print food.capitalize }
        ]]></script>
        <p>азначае &laquo;з кожным (анг. <code class="method">each</code>) словам 'toast', 'cheese', 'wine' зрабіць наступнае: пачатковую літару зрабіць вялікай (анг. <code class="method">capitalize</code>) і надрукаваць вынік (анг. <code class="method">print</code>).</p>
      </section>
      
      <section>
        <h1><a name="LangParts">Часткі мовы</a></h1>
        <p>Любая мова, у тым ліку і праграмаваньня, складаецца з пэўных частак. Разгледзем часткі, зь якіх складаецца Ruby.</p>
        
        <h2><a name="LangParts_Variables">Пераменныя</a></h2>
        <p>Пры дапамозе пераменных мы даём імёны аб&#39;ектам, каторыя часта выкарыстоўваюцца ў праграме. Пераменныя могуць састаяць з літараў, лічбаў і знака падкрэсьліваньня. Напрыклад, пераменная, якая ўтрымлівае аплату за ўваход у заапарк:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        zoo_entry_fee = 2.50
        ]]></script>
        <p><strong>УВАГА!</strong> Пераменныя больш нізкага ўзроўню ня проста перакрываюць пераменныя з тым жа імем больш высокага ўзроўню (як, напрыклад, у <a href="../javaRef/index.html"><span class="term">Java</span></a>):</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        verb = 'rescued'
        ['sedated', 'sprinkled', 'electrocuted'].each do |verb|
          puts "Dr. Cham " + verb + " his niece Hannah."
        end
        puts "Yes, Dr. Cham " + verb + " his niece Hannah."
        ]]></script>
        <p>але перавызначаць/заціраюць яе:</p>
        <script type="syntaxhighlighter" class="brush: text"><![CDATA[
        Dr. Cham sedated his niece Hannah.
        Dr. Cham sprinkled his niece Hannah.
        Dr. Cham electrocuted his niece Hannah.
        Yes, Dr. Cham electrocuted his niece Hannah.
        ]]></script>
        <p>Як бачым, у апошнім радку ў якасьці значэньня пераменнай <code class="local_var">verb</code> больш высокага ўзроўню падставіцца <i>"electrocuted"</i>&nbsp;&mdash; апошняе значэньне ітэратару, а не першапачатковае <i>"rescued"</i>, як магло б падацца.</p>
        
        <h2><a name="LangParts_Symbols">Сымбалі</a></h2>
        <p>Сымбалі выглядаюць амаль як лякальныя пераменныя, але перд імі ставіцца двукроп&#39;е і азначаюць яны палегчаныя радкі&nbsp;&mdash; стварыўшыся аднойчы, яны застаюцца ў памяці да канца працы праграмы і пры наступным выкарыстаньні проста бяруцца з памяці, а не ствараюцца па-новай. Вобласьць іх ужываньня&nbsp;&mdash; унутры праграмы, то бок гэта ня тыя радкі, каторыя прызначаныя для паказу карыстальніку. Прыклады:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        :a, :b, ці :ponce_de_leon
        ]]></script>
        
        <h2><a name="LangParts_Consts">Канстанты</a></h2>
        <p>Канстанты як пераменныя, але пачынаюцца зь вялікай літары і ня могуць зьмяняць сваё значэньня цягам працы праграмы:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        EmpireStateBuilding = "350 5th Avenue, NYC, NY"
        ]]></script>
        
        <h2><a name="LangParts_InstanceVar">Пераменныя экзэмпляраў</a></h2>
        <p>Пераменныя, каторыя пачынаюцца са знака &#64;, зьяўляюцца пераменнымі экзэмпляраў клясаў:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        @x, @y
        ]]></script>
        <p>Яны пазначаюць характарыстыку гэтага асабістага экзэмпляру. Напрыклад, каб пазначыць шырыню ўваходных дзьвярэй трэба ўвесьці пераменную <code class="var">&#64;width</code> у экзэмпляр <code class="local_var">front_door</code> клясы <code class="class">Door</code>.</p>
        
        <h2><a name="LangParts_ClassVar">Пераменныя клясаў</a></h2>
        <p>Пераменныя яшчэ больш высокага ўзроўню (у параўнаньні зь лякальнымі і экзэплярнымі)&nbsp;&mdash; пераменныя клясаў. Яны пачынаюцца з падвойнага знака &#64;:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        @@x, @@y
        ]]></script>
        <p>І пазначаюць характарыстыку ўсёй клясы (усіх экзэмпляраў гэтай клясы). Зьяўляюцца аналягамі статычных пераменных у <a href="../javaRef/index.html"><span class="term">Java</span></a>.</p>        
        
        <h2><a name="LangParts_GlobalVar">Глябальныя пераменныя</a></h2>
        <p>Ну і пераменнымі найбольш высокага ўзроўню зьяўляюцца глябальныя пераменныя. Яны пачынаюцца са знака &#36; і даступны зь любога месца праграмы:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        $x, $y
        ]]></script>
        
        <h2><a name="LangParts_Methods">Мэтады</a></h2>
        <p>Як ужо пазначалася вышэй мэтады&nbsp;&mdash; гэта запыты да аб&#39;ектаў. Каб зрабіць выклік мэтаду, пазначаецца пераменная ці канстанта, пасьля каторай ставіцца кропка і потым імя мэтаду:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        front_door.open
        ]]></script>
        <p>Выклікі мэтадаў могуць ісьці адзін за адным, таму што, як мы памятаем, вынік мэтаду&nbsp;&mdash; гэта таксама аб&#39;ект:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        front_door.open.close
        ]]></script>
        <p>Гэты складаны выклік кажа ўваходным дзьвярам адчыніцца і адразу ж зачыніцца. Імёны мэтадаў могуць утрымліваць клічнікі і пытальнікі:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        front_door.is_open?
        ]]></script>
        <p>Некаторыя мэтады зьяўляюцца ядром мовы і могуць быць выкліканы без пазначэньня экзэмпляру, да каторага яны адносяцца:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        print "Hello!"
        ]]></script>
        <p>Як гэта працуе? У Ruby на самым версе герархіі клясаў знаходзіцца кляса <code class="class">Object</code>. Усе мэтады гэтай клясы, адпаведна, калі не перавызначыныя яўна, успадкоўваюцца ўсімі іншымі клясамі. Дык вось у <code class="class">Object</code> <mark>дамешваецца</mark> модуль <code class="class">Kernel</code> (<i>kernel</i> па ангельску азначае <i>ядро</i>). Адпаведна, <a href="http://www.ruby-doc.org/core/classes/Kernel.html">усе мэтады ядра мовы</a> даступны глябальна і без патрэбы пазначаць экземпляр нейкай клясы.</p>
        
        <h3><a name="LangParts_Methods_redo">redo</a></h3>
        <p>Выклік <code class="keyword">redo</code> у мэтадзе прыводзіць да яго ж выкліку яшчэ раз:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        class LotteryTicket
          
          NUMERIC_RANGE = 1..25
          
          attr_reader :picks, :purchased
        
          def initialize(*picks)
            if picks.length != 3
              raise ArgumentError, "three numbers must be picked"
            elseif picks.uniq.length != 3
              raise ArgumentError, "the three pick must be different numbers"
            elseif picks.detect { |p| not NUMERIC_RANGE === p}
              raise ArgumentError, "the three pick must be numbers between 1 and 25"
          end
          
          @picks = picks
          @purchased = Time.now
        end
        
        def self.new_random
          new(rand(25) + 1, rand(25) + 1, rand(25) + 1)
        rescue ArgumentError
          redo
        end
        ]]></script>
        <p>Калі ў выпадку выкліку <code>LotteryTicket.new_random</code> будуць згенерэны хаця б дзьве аднолькавыя лічбы, тады <code>picks.uniq.length != 3</code> прывядзе да кіданьня памылкі, але <code>rescue ArgumentError</code> зловіць яе, а <code class="keyword">redo</code> выкліча мэтад <code class="method">new_random</code> яшчэ раз і гэта ўсё столькі разоў, пакуль усе 3 лічбы ня будуць унікальнымі.</p>
        
        <h2><a name="LangParts_MethodArguments">Аргумэнты мэтадаў</a></h2>
        <p>Некаторыя мэтады патрабуюць дадатковую інфармацыю, каб выканаць свае дзеяньні. Гэтую інфармацыю ім перадаюць пры дапамозе аргумэнтаў, каторыя ідуць пасьля імені мэтаду, заключаюцца ў дужкі (не абавязкова) і падзяляюцца коскамі:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        front_door.paint(3, :red)
        ]]></script>
        <p>Калі перад аргумэнтам мэтаду стаіць зорачка, гэта азначае, што можа быць любая колькасьць фактычных парамэтраў мэтаду і яны будуць перададзеныя як масіў:</code></p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        def initialize(*picks)
          if picks.length != 3
            raise ArgumentError, "three numbers must be picked"
          ...
        end
        ]]></script>
        
        <h2><a name="LangParts_ClassMethods">Мэтады клясаў</a></h2>
        <p>Мэтады клясаў (аналяг статычных мэтадаў у <a href="../javaRef/index.html"><span class="term">Java</span></a>) гэта запыты да клясаў, а не іх экзэмпляраў. Выклік адбываецца праз пазначэньне імені клясы, за каторым ідзе падвойнае двукропье і потым імя мэтаду:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        Door::new(:oak)
        ]]></script>
              
        <h2><a name="LangParts_Blocks">Блёкі</a></h2>
        <p>Пэўны код, заключаны ў фігурныя дужкі альбо паміж ключавымі словамі <code class="keyword">do</code>, называецца блёкам. Блёкі неабходны для групаваньня некалькіх інструкцый:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        2.times { 
          print "Hello!" 
          print "Hello!" 
        }
        
        loop do
          print "Much better." 
          print "Ah.  More space!" 
          print "My back was killin' me in those crab pincers." 
        end
        ]]></script>
        <p>Блёкі можна асацыяваць з выклікамі мэтадаў. Такія мэтады могуць выклікаць тады гэтыя блёкі пры дапамозе ключавога слова <code class="keyword">yield</code>:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        def sampleMethod
          yield
          yield
        end
        
        sampleMethod { puts "In the block" }
        ]]></script>
        <p>У выніку будзе выведзена на экран:</p>
        <script type="syntaxhighlighter" class="brush: text"><![CDATA[
        In the block
        In the block
        ]]></script>
        
        <h2><a name="LangParts_BlockArguments">Аргумэнты блёкаў і ітэратары</a></h2>
        <p>У блёкі могуць перадавацца аргумэнты. У гэтым выпадку яны зьмяшчаюцца ў самым пачатку блёку, заключаюцца ў знакі вертыкальных ліній і падзяляюцца коскамі:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        { |x, y| x + y }
        ]]></script>
        <p>У прыкладзе вышэй <code class="local_var">x</code> і <code class="local_var">y</code>&nbsp;&mdash; аргумэнты блёку, каторы ўтрымлівае адзіную інструкцыю&nbsp;&mdash; складаньне значэньняў гэтых аргумэнтаў.</p>
        <p>Аргумэнты блёкаў актыўна выкарыстоўваюцца ў ітэратарах:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        a = ['ant', 'bee', 'cat', 'dog', 'elk']   # ствараем масіў радкоў
        a.each { |animal| puts animal }           # ітэратар праходзіць праз элемэнты масіва, 
                                                  # каторыя перадаюцца ў якасьці аргумэнту animal у блёк
        ]]></script>
        <p>У выніку на экран будзе выведзена:</p>
        <script type="syntaxhighlighter" class="brush: text"><![CDATA[
        ant
        bee
        cat
        dog
        elk
        ]]></script>
        
        <h2><a name="LangParts_Operators">Апэратары</a></h2>
        <p>Апэратары выкарыстоўваюцца ў праграме для выкананьня матэматычных і лягічных апэрацый, для параўнаньня і інш. Поўны сьпіс апэратараў:</p>
        <table class="list" id="operators">
          <tbody>
            <tr>
              <td><code>**</code></td>
              <td><code>!</code></td>
              <td><code>~</code></td>
              <td><code>*</code></td>
              <td><code>/</code></td>
              <td><code>%</code></td>
              <td><code>+</code></td>
              <td><code>-</code></td>
              <td><code>&amp;</code></td>
              <td><code>|</code></td>
              <td><code>^</code></td>
            </tr>
            <tr>
              <td><code>&lt;&lt;</code></td>
              <td><code>&gt;&gt;</code></td>
              <td><code>&gt;</code></td>
              <td><code>&gt;=</code></td>
              <td><code>&lt;</code></td>
              <td><code>&lt;=</code></td>
              <td><code>&lt;=&gt;</code></td>
              <td><code>!=</code></td>
              <td><code>=~</code></td>
              <td><code>!~</code></td>
              <td><code>||</code></td>
            </tr>
            <tr>
              <td><code>&amp;&amp;</code></td>
              <td><code>+=</code></td>
              <td><code>-=</code></td>
              <td><code>==</code></td>
              <td><code>===</code></td>
              <td><code>..</code></td>
              <td><code>...</code></td>
              <td><code>not</code></td>
              <td><code>and</code></td>
              <td><code>or</code></td>
              <td></td>
            </tr>
          </tbody>
        </table>
        
        <h2><a name="LangParts_Keywords">Ключавыя словы</a></h2>
        <p>Як і ў любой іншай мове праграмаваньня, у Ruby ёсьць ключавыя словы, у каторыя закладзены пэўны сэнс. Поўны іх сьпіс:</p>
        <table class="list" id="keywords">
          <tbody>
            <tr>
              <td><code>alias</code></td>
              <td><code>and</code></td>
              <td><code>BEGIN</code></td>
              <td><code>begin</code></td>
              <td><code>break</code></td>
              <td><code>case</code></td>
            </tr>
            <tr>
              <td><code>class</code></td>
              <td><code>def</code></td>
              <td><code>defined</code></td>
              <td><code>do</code></td>
              <td><code>else</code></td>
              <td><code>elsif</code></td>
            </tr>
            <tr>
              <td><code>END</code></td>
              <td><code>end</code></td>
              <td><code>ensure</code></td>
              <td><code>false</code></td>
              <td><code>for</code></td>
              <td><code>if</code></td>
            </tr>
            <tr>
              <td><code>in</code></td>
              <td><code>module</code></td>
              <td><code>next</code></td>
              <td><code>nil</code></td>
              <td><code>not</code></td>
              <td><code>or</code></td>
            </tr>
            <tr>
              <td><code>redo</code></td>
              <td><code>rescue</code></td>
              <td><code>retry</code></td>
              <td><code>return</code></td>
              <td><code>self</code></td>
              <td><code>super</code></td>
            </tr>
            <tr>
              <td><code>then</code></td>
              <td><code>true</code></td>
              <td><code>undef</code></td>
              <td><code>unless</code></td>
              <td><code>until</code></td>
              <td><code>when</code></td>
            </tr>
            <tr>
              <td><code>while</code></td>
              <td><code>yield</code></td>
              <td><code></code></td>
              <td><code></code></td>
              <td><code></code></td>
              <td><code></code></td>
            </tr>
          </tbody>
        </table>
        
        
        
        
        <h2><a name="Basics_classes_attrs">Атрыбуты</a></h2>
        <p>Уводзіць у клясу пераменныя <code class="local_var">a</code> і <code class="local_var">b</code>:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        attr :a, :b
        ]]></script>
        <p>Уводзіць у клясу пераменныя <code class="local_var">a</code> і <code class="local_var">b</code>, а таксама <i>getter</i>- і <i>setter</i>-мэтады для ніх:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        attr_accessor :a, :b
        ]]></script>
        <p>Уводзіць у клясу пераменныя <code class="local_var">a</code> і <code class="local_var">b</code>, а таксама <i>getter</i>-мэтады для ніх:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        attr_reader :a, :b
        ]]></script>
        <p>Уводзіць у клясу пераменныя <code class="local_var">a</code> і <code class="local_var">b</code>, а таксама <i>setter</i>-мэтады для ніх:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        attr_writer :a, :b
        ]]></script>
        
        <h2><a name="Basics_classes_extending">Пашырэньне</a></h2>
        <p>Любая кляса, нават базавая, можа быць пашыраная:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        class String
          def new_method_name
            p "Hello the World!"
          end
        end
        
        "asdf".new_method_name
        ]]></script>
        <p>Папярэдні прыклад вывядзе ў кансоль <code>Hello the World!</code></p>

      </section>



      
      <section>
        <h1><a name="Types">Стандартныя тыпы</a></h1>
        <p>Стандартныя тыпы, як лікі, радкі сымбаляў і інш.&nbsp;&mdash; гэта базавыя цаглінкі, з каторых будуецца Ruby-праграма.</p>
        
        <h2><a name="Types_Object">Object</a></h2>
        <p><code class="class">Object</code> у Ruby зьяўляецца базавай клясай, каторая знаходзіцца ў самым версе герархіі клясаў. Усе астатнія клясы зьяўляюцца яго спадчыньнікамі, наўпроставымі ці ўскоснымі.</p>
        
        <h3><a name="Types_Object_Methods">Мэтады</a></h3>
        <div class="refs">
          <ul>
            <li><a href="http://ruby-doc.org/ruby-1.9/classes/Object.html">Object</a></li>
          </ul>
        </div>
        <p>Разгледзем у гэтым разьдзеле асноўныя мэтады, каторыя вызначаюцца ў <code class="class">Object</code>. Пры разглядзе іншых клясаў мэтады, прыведзеныя тут і сэнс каторых у тых клясах не зьмяняецца, рязглядацца ня будуць.</p>
        
        <h4><a name="Types_Object_Methods_ID">Вызначэньне ID аб&#39;екта</a></h4>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        # ніякія з любых двух аб'ектаў ня маюць аднолькавага ID
        "Hello".object_id #=> напр. 22628100
        ]]></script>
        
        <h4><a name="Types_Object_Methods_Class">Вызначэньне клясы аб&#39;екта</a></h4>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        1.class           #=> Fixnum
        "Hello".class     #=> String
        ]]></script>
        
        <h4><a name="Types_Object_Methods_InstanceOf">Праверка прыналежнасьці да клясаў</a></h4>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        module M;    end
        class A
          include M
        end
        class B < A; end
        class C < B; end
        b = B.new
        b.instance_of? A    #=> false
        b.instance_of? B    #=> true
        b.instance_of? C    #=> false
        b.instance_of? M    #=> false
        b.kind_of? A        #=> true
        b.kind_of? B        #=> true
        b.kind_of? C        #=> false
        b.kind_of? M        #=> true
        ]]></script>
        <p><code class="method">instance_of?</code>&nbsp;&mdash; строгая праверка прыналежнасьці аб&#39;екта да пэўнай клясы (без уліку герархіі і ўключаных модуляў). <code class="method">kind_of?</code> (альбо <code class="method">is_a?</code>)&nbsp;&mdash; мяккая праверка прыналежнасьці аб&#39;екта да клясы, то бок ня толькі непасрэднай клясы, але і ўсёй герархіі клясаў альбо ўключаных модуляў (гл. прыклад вышэй). Будзьце ўважлівымі тыя, хто пераходзіць да вывучэньня Ruby з <a href="../javaRef/index.html"><span class="term">Java</span></a>. Той сэнс, каторы рэалізаваны яваўскім <code class="method">instance_of</code>, у Ruby рэалізуецца мэтадам <code class="method">kind_of?</code> (альбо <code class="method">is_a?</code>), а не <code class="method">instance_of?</code>.</p>
        
        <h4><a name="Types_Object_Methods_Compare">Апэрацыі параўнаньня</a></h4>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        # правярае ці спасылаюцца ідэнтыфікатары (пераменныя) на тыя ж самыя аб'екты
        a = "Hello"
        b = "Hello"
        a.equal? b        #=> false - ня гледзячы на тое, што a і b маюць адно 
                          # і тое ж значэньне, спасылаюцца яны на розныя аб'екты
        
        # звычайна, калі не пазначана інакш у адпаведнай клясе, параўнаньне значэньняў аб'ектаў:
        1 == 1.0          #=> true
        a.eql? b          #=> true (a i b - радкі "Hello", вызначаныя вышэй)

        # параўноўвае значэньні аб'ектаў а-ля Comparable:
        1 <=> 1           #=> 0
        1 <=> 2           #=> -1
        2 <=> 1           #=> 1
        ]]></script>
        
        <h4><a name="Types_Object_Methods_nil">Праверка на <code class="keyword">nil</code></a></h4>
        <p>Аб&#39;ект, каторы нікуды не спасылаецца, ня проста "нішто", як напрыклад у <a href="../javaRef/index.html"><span class="term">Java</span></a>, але пусты аб&#39;ект, у каторага можна выклікаць пэўныя мэтады. Адным з такіх мэтадаў і зьяўляецца праверка на тое, пусты аб&#39;ект ці не:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        nil.nil?          #=> true
        
        a = 5
        a.nil?            #=> false
        a = nil
        a.nil?            #=> true
        ]]></script>
        
        <h4><a name="Types_Object_Methods_Clone">Кланаваньне</a></h4>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        class Klass
            attr_accessor :str
        end
        s1 = Klass.new
        s1.str = "Hello"    #=> s1.str="Hello"
        s2 = s1.clone       #=> s2.str="Hello"
        s3 = s1.dup         #=> s3.str="Hello"
        s2.str[1,4] = "i"   #=> s1.str="Hi", s2.str="Hi", s3.str="Hi"
        ]]></script>
        <p>Мэтады <code class="method">clone</code> і <code class="method">dup</code> у <code class="class">Object</code> падобны&nbsp;&mdash; яны капіруюць пераменныя аднаго экзэмпляру ў іншы. Пры гэтым капіруюцца спасылкі, а не значэньні. Але адрозьніваюцца яны тым, што мэтад <code class="method">clone</code> акрамя гэтага капіруе яшчэ і <a href="#Types_Object_Methods_Freeze"><code class="method">frozen</code></a>-стан экзэмпляру, а <code class="method">dup</code> гэтага ня робіць.</p>
        
        <h4><a name="Types_Object_Methods_Freeze">Замарозка</a></h4>
        <p>Мэтад <code class="method">freeze</code> прадухіляе аб&#39;ект ад далейшых зьменаў.</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        a = [ "a", "b", "c" ]
        a.freeze
        a.frozen?           #=> true
        a << "z"            #=> prog.rb:4:in `<<': can't modify frozen array (RuntimeError)
                            #=> from prog.rb:4
        ]]></script>
        
        <h4><a name="Types_Object_Methods_StrRepr">Радковае прадстаўленьне аб&#39;ектаў</a></h4>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        class Klass
            attr_accessor :str
        end
        s1 = Klass.new
        s1.str = "Hello"
        s1.inspect          #=> "#<Klass:0x2922a68 @str=\"Hello\">"
        s1.to_s             #=> "#<Klass:0x2922a68>"
        ]]></script>
        <p>Мэтад <code class="method">inspect</code> вяртае радок, які ўтрымлівае чытэльнае чалавекам прадстаўленьне аб&#39;екта. Мэтад <code class="method">to_s</code>, вызначаны ў <code class="class">Object</code>, вяртае імя клясы і ID аб&#39;екта.</p>
        
        <h4><a name="Types_Object_Methods_ClassStructure">Мэтады інспэкцыі структуры клясы</a></h4>
        <p>Асобнай групай стаяць мэтады інспэкцыі структуры клясы&nbsp;&mdash; вызначэнье якія ёсьць у аб&#39;екта пераменныя, мэтады і іншыя атрыбуты:</p>        
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        class Klass
          attr_accessor :a1
          
          def initialize(p1)
            @a2 = 3
            @a3 = p1
          end
          
          def kMethod()
          end
        end
        k = Klass.new
        
        # масіў усіх мэтадаў, каторыя могуць быць выкліканыя ў аб&#39;екта:
        k.methods           #=> ["kMethod", "freeze", "nil?", "is_a?", "class", ... і гэтак далей
        
        # масіў прыватных, пратэктэд і паблік мэтадаў, каторыя могуць быць выкліканыя ў аб'екта:
        k.private_methods
        k.protected_methods
        k.public_methods
        
        # правярае ці мае аб'ект пэўны мэтад:
        k.respond_to?("aMethod")  #=> false
        k.respond_to?("kMethod")  #=> true
        
        # масіў пераменных аб&#39;екта (зьвярніце ўвагу, што аб'яўленьне accessor'аў - a1 у нашым
        # выпадку, не прыводзіць да ўстаўкі паўнавартасных пераменных):
        k.instance_variables      #=> [:@a1, :@a2]
        
        # правярае ці мае аб'ект пераменную:
        instance_variable_defined?(:@a1)      #=> true
        instance_variable_defined?("@a2")     #=> true
        instance_variable_defined?(:@b)       #=> false
        ]]></script>
        
        <h2><a name="Types_Numbers">Лікі</a></h2>
        <p>Ruby падтрымлівае цэлыя і рэчаісныя лікі.</p>
        
        <h3><a name="Types_Numbers_Integers">Цэлыя</a></h3>
        <p>Цэлыя лікі складаюцца з пасьлядоўнасьці лічбаў, перад каторымі <i>можа</i> стаяць знак плюсу ці мінусу:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        1, 23, -10000
        ]]></script>
        <p>У мэтах візуальнага падзяленьня тысячаў у ліках дазваляецца выкарыстоўваць знак падкрэсьліваньня:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        population = 12_000_000_000
        ]]></script>
        <p>Цэлыя могуць быць адвольнай дліны ці памеру (аж да значэньня, каторае абмежавана даступнай свабоднай памяцьцю кампутара). У межах пэўнага дыяпазону (звычайна ад -2<sup>30</sup> да 2<sup>30</sup>-1 ці ад -2<sup>62</sup> да 2<sup>62</sup>-1) цэлыя прадстаўляюцца як аб&#39;екты клясы <code class="class">Fixnum</code>&nbsp;&mdash; малыя цэлыя. Калі ж яны выходзяць за гэты дыяпазон, то Ruby пераводзіць іх у аб&#39;екты клясы <code class="class">Bignum</code>&nbsp;&mdash; вялікія цэлыя, і наадварот. Прычым гэты працэс пераводу лікаў з <code class="class">Fixnum</code> у <code class="class">Bignum</code> і наадварот&nbsp;&mdash; празрысты для распрацоўшчыка, Ruby робіць гэта сам:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        num = 8
        7.times do
          print num.type, " ", num, "\n"
          num *= num
        end
        ]]></script>
        <p>У выніку на экран будзе выведзена:</p>        
        <script type="syntaxhighlighter" class="brush: text"><![CDATA[
        Fixnum 8
        Fixnum 64
        Fixnum 4096
        Fixnum 16777216
        Bignum 281474976710656
        Bignum 79228162514264337593543950336
        Bignum 6277101735386680763835789423207666416102355444464034512896
        ]]></script>
        <p>Цэлыя могуць быць таксама запісаныя ў васьмірычным, шаснаццацірычным ці дваічным выглядзе:</p>        
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        0377            # васьмірычны выгляд, з прэфіксам 0
        0xaabb          # шаснаццацірычны выгляд, з прэфіксам 0x
        0b101_010       # бінарны выгляд, з прэфіксам 0b
        ]]></script>
        <p>Акрамя гэтага цэлы лік, як адлюстраваньне коду сымбалю, можна атрымаць паставіўшы знак пытальніку перад гэтым сымбалем:</p>        
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        ?a              # код сымбалю 'a' (0x61)
        ?\n             # код пераводу радка (0x0a)
        ]]></script>
        
        <h3><a name="Types_Numbers_Float">Рэчаісныя</a></h3>
        <p>Рэчаісныя лікі складаюцца з пасьлядоўнасьці лічбаў і нефіксаванай кропкі ці навуковай натацыі:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        3.14, -808.08, 12.043e-04
        ]]></script>
        <p>Зьвярніце ўвагу, што пасьля нефіксаванай кропкі абавязкова павінна стаяць лічба:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        1.e3            # у гэтым выпадку Ruby паспрабуе выклікаць мэтад e3 у цэлага 1
        ]]></script>
        
        <h3><a name="Types_Numbers_Methods">Мэтады</a></h3>
        <div class="refs">
          <ul>
            <li><a href="http://ruby-doc.org/ruby-1.9/classes/Numeric.html">Numeric</a></li>
            <li><a href="http://ruby-doc.org/ruby-1.9/classes/Integer.html">Integer</a></li>
            <li><a href="http://ruby-doc.org/ruby-1.9/classes/Fixnum.html">Fixnum</a></li>
            <li><a href="http://ruby-doc.org/ruby-1.9/classes/Bignum.html">Bignum</a></li>
            <li><a href="http://ruby-doc.org/ruby-1.9/classes/Float.html">Float</a></li>
            <li><a href="http://ruby-doc.org/ruby-1.9/classes/BigDecimal.html">BigDecimal</a></li>
          </ul>
        </div>
        <p>Коратка пра мэтады, каторыя прадстаўляюцца лікамі (поўныя сьпісы і тлумачэньні даступныя па спасылкам зьлева):</p>
        
        <h4><a name="Types_Numbers_Methods_Math">Матэматычныя апэрацыі</a></h4>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        1 + 2             #=> 3 (складаньне)
        5 - 3             #=> 2 (адніманьне)
        2 * 3             #=> 6 (памнажэньне)
        5 / 3             #=> 1 (цэлалікавае дзяленьне)
        6 / 4.0           #=> 1.25 (рэчаіснае дзяленьне)
        2 ** 3            #=> 8 (ступень)
        1.next            #=> 2 (інкрэмэнт, тое ж што і 1.succ)
        ]]></script>
        
        <h4><a name="Types_Numbers_Methods_Binary">Бінарныя апэрацыі</a></h4>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        1 & 2             #=> 3 (бінарнае AND)
        1 ^ 5             #=> 4 (бінарнае XOR)
        1 | 3             #=> 3 (бінарнае OR)
        ~4                #=> 3 (бінарнае адмаўленьне)
        
        4 >> 1            #=> 2 (бінарны зрух управа, "хуткае дзяленьне на адпаведную ступень 2")
        4 << 1            #=> 8 (бінарны зрух улева, "хуткае памнажэньне на адпаведную ступень 2")
        ]]></script>
        
        <h4><a name="Types_Numbers_Methods_Compare">Апэрацыі параўнаньня</a></h4>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        1 < 2             #=> true (строгае меньш)
        1 > 2             #=> false (строгае больш)
        1 <= 1            #=> true (меньш альбо роўна)
        2 >= 1            #=> true (больш альбо роўна)
        1 == 1.0          #=> true (параўнаньне значэньняў)
        
        # параўноўвае значэньні а-ля Comparable:
        1 <=> 1           #=> 0
        1 <=> 2           #=> -1
        2 <=> 1           #=> 1
        
        # параўноўвае тыпы і значэньні (true толькі калі роўныя і тыпы, і значэньні):
        1.eql?(1.0)       #=> false
        (1.0).eql?(1.0)   #=> true
        ]]></script>
        
        <h4><a name="Types_Numbers_Methods_CriteriaCheck">Праверкі адпавяданьня пэўнаму крытэру</a></h4>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        # правярае ці лік цэлы:
        1.integer?        #=> true
        1.2.integer?      #=> false
        
        # правярае ці лік не нулявы:
        1.nonzero?        #=> 1
        0.nonzero?        #=> nil

        # правярае ці лік нулявы:
        1.zero?           #=> false
        0.zero?           #=> true

        # правярае ці лік цотны/няцотны:
        2.even?           #=> true
        1.odd?            #=> true
        ]]></script>
        
        <h4><a name="Types_Numbers_Methods_NumberTransform">Мэтады лікавых трасфармацый</a></h4>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        # модуль ліку:
        -12.abs           #=> 12
        
        # бліжэйшае большае цэлае:
        1.2.ceil          #=> 2
        (-1.2).ceil       #=> -1
   
        # бліжэйшае меншае цэлае:
        1.2.floor         #=> 1
        (-1.2).floor      #=> -2
        
        # акругленьне і адкіданьне дробнай часткі:
        1.5.round         #=> 2
        1.5.truncate      #=> 1 (тое ж што і to_i, to_int для рэчаісных лікаў)
        ]]></script>
        
        <h4><a name="Types_Numbers_Methods_Iterators">Ітэратары</a></h4>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        5.times { |i| print i, " " }        #=>0 1 2 3 4
        5.downto(1) { |i| print i, " " }    #=>5 4 3 2 1
        5.upto(10) { |i| print i, " " }     #=>5 6 7 8 9 10
        50.step(80, 5) { |i| print i, " " } #=>50 55 60 65 70 75 80
        ]]></script>
        
        <h4><a name="Types_Numbers_Methods_TypeTransform">Мэтады трасфармацый у іншыя тыпы</a></h4>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        # трансфармацыя ў сымбаль, чый код прадстаўляе лік:
        65.chr                      #=> "A"
        255.chr(Encoding::UTF_8)    #=> "\303\277"
        
        # трансфармацыя ў радок:
        12345.to_s        #=> "12345" (то е ж што і 12345.to_s(10))
        12345.to_s(2)     #=> "11000000111001"
        12345.to_s(16)    #=> "3039"
   
        # трансфармацыя ў рэчаісны лік (калі Bignum трансфармуецца і яго значэньне не зьмяшчаецца 
        # у Float, вынік будзе нявызначаны):
        5.to_f            #=> 5.0

        # трансфармацыя ў цэлы лік:
        1.5.to_i          #=> 1 (тое ж што і to_int, trancate для рэчаісных лікаў)
        
        ]]></script>

        <h4><a name="Types_Numbers_Methods_DivideModulo">Мэтады дзяленьня і знаходжаньня астачы</a></h4>
        <p>Асобна спынімся на мэтадах дзяленьня і знаходжаньня астачы (рэшты) ад цэлага дзяленьня. Заўважым, што мэтад <code class="method">divmod</code> вяртае не адно, а масіў значэньняў. Прычым, калі <code>q, r = x.divmod(y)</code>, тады:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        q = floor(float(x)/float(y))
        x = q*y + r
        ]]></script>
        <p>Параўнаўчая табліца:</p>        
        <pre>
           &nbsp;&nbsp;a &nbsp;&nbsp;| &nbsp;b | a.divmod(b) | a.div(b), a/b | a.modulo(b), a%b | a.remainder(b)
           ------+----+-------------+---------------+------------------+---------------
           &nbsp;13 &nbsp;&nbsp;| &nbsp;4 | &nbsp;&nbsp;3, &nbsp;&nbsp;1 &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1
           ------+----+-------------+---------------+------------------+---------------
           &nbsp;13 &nbsp;&nbsp;| -4 | &nbsp;-4, &nbsp;-3 &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;-3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1
           ------+----+-------------+---------------+------------------+---------------
           -13 &nbsp;&nbsp;| &nbsp;4 | &nbsp;-4, &nbsp;&nbsp;3 &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;-4 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;-1
           ------+----+-------------+---------------+------------------+---------------
           -13 &nbsp;&nbsp;| -4 | &nbsp;&nbsp;3, &nbsp;-1 &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;-1
           ------+----+-------------+---------------+------------------+---------------
           &nbsp;11.5 | &nbsp;4 | &nbsp;&nbsp;2, &nbsp;&nbsp;3.5 &nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.875 &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.5 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.5
           ------+----+-------------+---------------+------------------+---------------
           &nbsp;11.5 | -4 | &nbsp;-3, &nbsp;-0.5 &nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;-2.875 &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-0.5 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.5
           ------+----+-------------+---------------+------------------+---------------
           -11.5 | &nbsp;4 | &nbsp;-3, &nbsp;&nbsp;0.5 &nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;-2.875 &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.5 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;-3.5
           ------+----+-------------+---------------+------------------+---------------
           -11.5 | -4 | &nbsp;&nbsp;2, &nbsp;-3.5 &nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.875 &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-3.5 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;-3.5
        </pre>

        <h2><a name="Types_Enumerable">Пералічэньне</a></h2>
        <p><mark>Модуль</mark> <code class="class">Enumerable</code> выкарыстоўваецца ў якасьці <mark>дамешка</mark> да іншых тыпаў, каб надаць ім уласьцівасьці пералічэньняў.</p>

        <h2><a name="Types_Strings">Радкі</a></h2>
        <p>Радкі&nbsp;&mdash; гэта пасьлядоўнасьць любых сымбаляў (літараў, лічбаў, знакаў прыпынку), якія ўзяты ў апострафы ці двукосьсе. Уключаюць у сябе <mark>дамешак</mark> <a href="#Types_Enumerable"><code class="class">Enumerable</code></a>.</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        "sealab", '2021', ці "These cartoons are hilarious!"
        ]]></script>
        <p>У радках, каторыя ўзятыя ў адзіночныя апострафы, дазваляюцца простыя <i>sequence</i>-пасьлядоўнасьці:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        'escape using "\\"'     #=> escape using "\"
        'That\'s right'         #=> That's right
        ]]></script>
        <p>У радках, ўзятых ў двукосьсе, дазваляецца большая колькасьць <i>sequence</i>-пасьлядоўнасьцяў (напр. "\n"). Акрамя гэтага ў такія радкі можна падставіць любы выраз пры дапамозе <code>#{ }</code>:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        "Seconds/day: #{24*60*60}"      #=> Seconds/day: 86400
        "#{'Ho! '*3}Merry Christmas"    #=> Ho! Ho! Ho! Merry Christmas
        "This is line #$."              #=> This is line 3
        ]]></script>
        <p>Каб пазначыць адзін сымбаль/знак (не радок з аднаго знаку, а менавіта знак), перад ім ставіцца пытальнік:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        "hello".index(?e)               #=> 1
        ]]></script>
        
        <h3><a name="Types_Strings_Methods">Мэтады</a></h3>
        <div class="refs">
          <ul>
            <li><a href="http://ruby-doc.org/ruby-1.9/classes/String.html">String</a></li>
          </ul>
        </div>
        <p>Коратка пра мэтады, каторыя прадстаўляюцца радкамі (поўны сьпіс і тлумачэньне даступныя па спасылцы зьлева).</p>
        
        <h4><a name="Types_Strings_Methods_Size">Памер радка</a></h4>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        # правярае ці пусты радок:
        "hello".empty?      #=> false
        "".empty?           #=> true

        # вяртае колькасьць сымбаляў у радку:
        "hello".length      #=> 5
        "hi".size           #=> 2
        ]]></script>
        
        <h4><a name="Types_Strings_Methods_Compare">Параўнаньне радкоў</a></h4>
        <p>Акрамя <a href="#Types_Object_Methods_Compare">стандартных мэтадаў параўнаньня</a>, у <code class="class">String</code> яшчэ існуе мэтад параўнаньня радкоў аналягічны мэтаду <code class="class"><String>&lt;=&gt;</code>, але без уліку рэгістру літар:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        "abcdef".casecmp("abcde")     #=> 1
        "aBcDeF".casecmp("abcdef")    #=> 0
        "abcdef".casecmp("abcdefg")   #=> -1
        "abcdef".casecmp("ABCDEF")    #=> 0
        ]]></script>
        
        <h4><a name="Types_Strings_Methods_Array">Паэлемэнтны доступ</a></h4>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        a = "hello there"
        a[1]                  #=> "e" (доступ да сымбалю з індэксам 1)
        a[1,3]                #=> "ell" (доступ да 3х сымбаляў пачынаючы з індэксу 1)
        a[1..3]               #=> "ell" (доступ да сымбаляў з індэксамі 1..3)
        a[-3,2]               #=> "er" (у выпадку адмоўных значэньняў індэкс лічыцца з канца)
        a[-4..-2]             #=> "her"
        a[12..-1]             #=> nil
        a[-2..-4]             #=> ""
        a[/[aeiou](.)\1/]     #=> "ell" (у выпадку рэгулярных выразаў, вяртаецца знойдзены радок)
        a[/[aeiou](.)\1/, 0]  #=> "ell" (калі другім парамэтрам ідзе лік, вяртаецца адпаведны
        a[/[aeiou](.)\1/, 1]  #=> "l"   кампанэнт у MatchData)
        a[/[aeiou](.)\1/, 2]  #=> nil
        a["lo"]               #=> "lo"  (вяртаецца перададзены ў якасьці аргумэнту радок,
        a["bye"]              #=> nil   калі знойдзены ў якасьці падрадку ў зыходным)
        ]]></script>
        <p>Акрамя формы а-ля масіў, прыведзенай у прыкладзе вышэй, можна яшчэ ўжываць мэтад <code class="method">slice</code>&nbsp;&mdash; бязь зьмены зыходнага радку, ці <code class="method">slice!</code>&nbsp;&mdash; са зьменай зыходнага радку.</p>
        
        <h4><a name="Types_Strings_Methods_ContentTransforms">Мадыфікацыя зьместу</a></h4>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        # "абнуленьне" радку:
        s = "Hello!"            #=> "Hello!"
        s.clear                 #=> ""
        
        # дубляваньне радку пэўную колькасьць разоў:
        "Ho! " * 3              #=> "Ho! Ho! Ho! "
        
        # канкатэнацыя радкоў:
        "Hello " + "world!"     #=> "Hello world!"
        a = "Hello "
        a << "world"            #=> "Hello world"
        a.concat(33)            #=> "Hello world!" (калі ў выпадку << ці concat аргумэнтам
                                #   зьяўляецца цэлы лік, ён трактуецца як код знаку)
        
        # пераварочваньне радку (існуе форма reverse!):
        "stressed".reverse      #=> "desserts"

        # устаўка і замена падрадкоў:
        "abcd".insert(0, 'X')   #=> "Xabcd"
        "abcd".insert(4, 'X')   #=> "abcdX"
        "abcd".insert(-3, 'X')  #=> "abXcd"
        "abcd".insert(-1, 'X')  #=> "abcdX"
        s = "hello"             #=> "hello"
        s.replace "world"       #=> "world"

        # адкідваньне з канца радку знаку "перавод радка" (\n, \r ці \r\n), калі выкліканы без
        # аргумэнтаў, ці падрадку, пазначанага ў якасьці аргумэнту (існуе форма chomp!): 
        "hello".chomp           #=> "hello"
        "hello\n".chomp         #=> "hello"
        "hello\r\n".chomp       #=> "hello"
        "hello\n\r".chomp       #=> "hello\n"
        "hello\r".chomp         #=> "hello"
        "hello \n there".chomp  #=> "hello \n there"
        "hello".chomp("llo")    #=> "he"
        
        # адкіданьне галаўных і канцавых прагалаў (для ўсіх 3х функцыяў існуюць варыянты з !):
        "    hello    ".strip   #=> "hello"
        "\tgoodbye\r\n".strip   #=> "goodbye"
        "  hello  ".rstrip      #=> "  hello"
        "  hello  ".lstrip      #=> "hello  "
        
        # замена ў радку яго пэўнага падрадку на іншы падрадок. sub - замяняе першы знойдзены
        # падрадок, gsub - усе знойдзеныя падрадкі. Існуюць формы мэтадаў з !
        "hello".gsub(/[aeiou]/, '*')                  #=> "h*ll*"
        "hello".gsub(/([aeiou])/, '<\1>')             #=> "h<e>ll<o>"
        "hello".gsub(/./) {|s| s[0].ord.to_s + ' '}   #=> "104 101 108 108 111 "
        "hello".gsub(/(?<foo>[aeiou])/, '{\k<foo>}')  #=> "h{e}ll{o}" 
        ]]></script>
        
        <h4><a name="Types_Strings_Methods_CaseTransforms">Мадыфікацыя рэгістру літар</a></h4>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        # першая літара радку - з вялікай літары, астатнія - малыя (існуе форма з !):
        "hello world".capitalize    #=> "Hello world"
        "HELLO".capitalize          #=> "Hello"
        "123ABC".capitalize         #=> "123abc"

        # усе літары радку робіць вялікімі (існуе форма з !):
        "hEllO".upcase              #=> "HELLO"

        # усе літары радку робіць малымі (існуе форма з !):
        "hEllO".downcase            #=> "hello"

        # робіць рэгістар літар зваротным (існуе форма з !):
        "Hello".swapcase            #=> "hELLO"
        "cYbEr_PuNk11".swapcase     #=> "CyBeR_pUnK11"
        ]]></script>
        
        <h4><a name="Types_Strings_Methods_Rundown">Паэлемэнтны перабор</a></h4>
        <p>Існуюць 4 мэтады: <code class="method">bytes</code>, <code class="method">chars</code>, <code class="method">codepoints</code> і <code class="method">lines</code>, а таксама іх аналягі з прэфіксам <code>each_</code>. Першыя чатыры, калі ім перадаецца блёк, аналягічныя апошнім чатыром. Калі ж яны выклікаюцца бяз блёку, то проста вяртаюць пералічэньне з байтаў, сымбаляў, кодаў ці радкоў адпаведна.</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        "hello".bytes.to_a                      #=> [104, 101, 108, 108, 111]
        "hello".each_byte {|c| print c, ' ' }   #=> 104, 101, 108, 108, 111
        
        "foo".chars.to_a                        #=> ["f","o","o"]
        
        "foo\nb ar".lines.sort                  #=> ["b ar", "foo\n"]

        "hello\u0639".each_codepoint {|c| print c, ' ' }    #=> 104 101 108 108 111 1593
        ]]></script>
        
        <h4><a name="Types_Strings_Methods_Analysis">Разбор радка</a></h4>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        # ці пачынаецца радок з пазначанага падрадку:
        "Hello".start_with?("He")       #=> true
        
        # ці ўключае радок пазначаны падрадок:
        "Hello".include?("Hi")          #=> false
        
        # вяртае індэкс, з каторага пазначаны падрадок уключаецца ў зыходны радок:
        "hello".index('e')              #=> 1
        "hello".index('lo')             #=> 3
        "hello".index('a')              #=> nil
        "hello".index(/[aeiou]/, -3)    #=> 4 (калі другім аргумэнтам пазначаны цэлы лік, ён кажа зь 
                                        #      якога індэксу зыходнага радку трэба пачынаць пошук)
        
        # дзяленьне радку па пэўным падзяляльнікам:
        " now's  the time".split        #=> ["now's", "the", "time"]
        " now's  the time".split(' ')   #=> ["now's", "the", "time"]
        " now's  the time".split(/ /)   #=> ["", "now's", "", "the", "time"]
        "1, 2.34,56, 7".split(%r{,\s*}) #=> ["1", "2.34", "56", "7"]
        "hello".split(//)               #=> ["h", "e", "l", "l", "o"]
        "mellow yellow".split("ello")   #=> ["m", "w y", "w"]
        
        a = "cruel world"
        a.scan(/\w+/)                   #=> ["cruel", "world"]
        a.scan(/.../)                   #=> ["cru", "el ", "wor"]
        a.scan(/\w+/) {|w| print "<<#{w}>> " }      #=> <<cruel>> <<world>>
        
        # таксама падзяляе радок, але толькі на: 1. тое што да падзяляльніка; 2. падзяляльнік;
        # 3. тое, што пасьля падзяляльніка. Існуе таксама форма rpartition, каторая шукае з канца.
        "hello".partition("l")          #=> ["he", "l", "lo"]
        "hello".partition("x")          #=> ["hello", "", ""]
        "hello".partition(/.l/)         #=> ["h", "el", "lo"]
        
        # шукае ўваходжаньне <i>regexp</i>-патэрнаў у радку і вяртае экзэмпляр MatchData
        'hello'.match('(.)\1')          #=> #<MatchData "ll" 1:"l">
        ]]></script>
        
        <h4><a name="Types_Strings_Methods_Encoding">Кадоўка знакаў</a></h4>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        # атрыманьне цяперашняй кадоўкі знакаў радку:
        "Hello".encoding                #=> #<Encoding:IBM866> (аб'ект клясы Encoding)
        
        # ужыць кадоўку: мэтады encode, encode!, force_encoding
        # больш падрабязна гл. афіцыйны даведнік
        
        # праверыць ці кадоўка валідная:
        "\xc2\xa1".force_encoding("UTF-8").valid_encoding?    #=> true
        "\xc2".force_encoding("UTF-8").valid_encoding?        #=> false
        "\x80".force_encoding("UTF-8").valid_encoding?        #=> false 
        ]]></script>
        
        <h4><a name="Types_Strings_Methods_TypeTransforms">Трансфармацыя ў іншыя тыпы</a></h4>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        # у рэчаісны лік:
        "123.45e1".to_f         #=> 1234.5
        "45.67 degrees".to_d    #=> 45.67
        "thx1138".to_f          #=> 0.0
        
        # у цэлы лік:
        "12345".to_i            #=> 12345
        "99 red balloons".to_i  #=> 99
        "0a".to_i               #=> 0
        "0a".to_i(16)           #=> 10
        "hello".to_i            #=> 0
        "1100101".to_i(16)      #=> 17826049
        ]]></script>
        
        <h2><a name="Types_Ranges">Дыяпазоны</a></h2>
        <p>Дыяпазоны паўсюдна сустракаюцца ў штодзённым жыцьці: са студзеня па люты, ад 0 да 9, радкі з 57 па 60 і г.д. Ruby падтрымлівае гэтыя існасьці праз тып <code class="class">Range</code>. Прычым у Ruby гэты тып выкарыстоўваецца для прадстаўленьня <i>пасьлядоўнасьцей</i>, <i>умоваў</i> і <i>інтэрвалаў</i>. Дыяпазоны ўключаюць у сябе дамешак <a href="#Types_Enumerable"><code class="class">Enumerable</code></a>.</p>
        
        <h3><a name="Types_Ranges_AsSequences">Як пасьлядоўнасьці</a></h3>
        <p>Найбольш натуральнае выкарыстаньне дыяпазонаў&nbsp;&mdash; для прадстаўленьня пасьлядоўнасьцяў. Запісваюцца яны праз пазначэньне пачатковага значэньня, потым ідзе апэратар дыяпазону, пасьля каторага пазначаецца канцавое значэньне пасьлядоўнасьці. Апэратарам дыяпазону можа быць альбо <code>..</code> (з уключэньнем апошняга пазначанага значэньня пасьлядоўнасьці), альбо <code>...</code> (без уключэньня апошняга значэньня):</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        'a'..'z'                # пасьлядоўнасьць усіх радковых літар лацінскага альфабэту
        1...9                   # пасьлядоўнасьць лічбаў ад 1 па 8 уключна, без уліку апошняга значэньня 9
        ]]></script>
        <p>Унутрана дыяпазоны захоўваюцца ня ў выглядзе сьпісу з усіх значэньняў, а ў выглядзе пачатковага і канцавога значэньняў. Таму, каб атрымаць сьпіс значэньняў, трэба выклікаць мэтад <code class="method">to_a</code>, каторы пераўтворыць дыяпазон у масіў усіх яго значэньняў:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        1..10                   #=> 1..10 (выводзіць не пералік усіх значэньняў, а пачатковае і канцавое)
        (1..10).to_a            #=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] (пералік усіх значэньняў)
        ]]></script>
        <p>Дыяпазоны можна ўтвараць ня толькі з лікаў ці сымбаляў, але і з любых іншых аб&#39;ектаў. Але існуюць пэўныя патрабаваньні да клясаў, чые экзэмпляры могуць утвараць дыяпазоны: 1. утрымліваць <mark>дамешак</mark> <code class="class">Comparable</code> і, адпаведна, <em>правільна</em> рэалізоўваць мэтад <code class="method">&lt;=&gt;</code>; 2. рэалізоўваць мэтад <code class="method">succ</code>, каторы вяртае наступны элемэнт у дыяпазоне:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        class VU
          include Comparable
        
          attr :volume
        
          def initialize(volume)  # 0..9
            @volume = volume
          end
        
          def inspect
            '#' * @volume
          end
        
          # Рэалізоўваем падтрымку дыяпазонаў:
        
          def <=>(other)
            self.volume <=> other.volume
          end
        
          def succ
            raise(IndexError, "Значэньне завялікае") if @volume >= 9
            VU.new(@volume.succ)
          end
        end
        ]]></script>
        <p>Пасьля гэтага магчымае наступнае ўжываньне:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        m = VU.new(4)..VU.new(7)
        m.to_a                       #=> [####, #####, ######, #######]
        m.include?(VU.new(3))        #=> false
        ]]></script>
        
        <h3><a name="Types_Ranges_AsConditions">Як умовы</a></h3>
        <p>Акрамя пасьлядоўнасьцяў дыяпазоны ўжываюцца ў якасьці ўмоўных выразаў:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        while input = gets
          puts input if input =~ /start/ .. input =~ /end/
        end
        ]]></script>
        
        <h3><a name="Types_Ranges_AsIntervals">Як інтэрвалы</a></h3>
        <p>А яшчэ дыяпазоны ўжываюцца для праверкі ці ўваходзіць значэньне ў пэўны інтэрвал пры дапамозе апэратару <code>===</code>:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        (1..10) === 5              #=> true    (5 уваходзіць у інтэрвал значэньняў ад 1 да 10
        (1..10) === 15             #=> false    а 15 не ўваходзіць)
        ]]></script>
        <p>Апэратар <code>===</code> яшчэ называецца <code class="keyword">case</code>-параўнальным апэратарам, таму што выкарыстоўваецца ў аператары <code class="keyword">case</code>, калі ў ім ужываюцца дыяпазоны:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        score = 70

        result = case score
          when 0..40 then "Fail"
          when 41..60 then "Pass"
          when 61..70 then "Pass with Merit"
          when 71..100 then "Pass with Distinction"
          else "Invalid Score"
        end                         #=> "Pass with Merit"
        ]]></script>
        
        <h3><a name="Types_Ranges_Methods">Мэтады</a></h3>
        <div class="refs">
          <ul>
            <li><a href="http://ruby-doc.org/ruby-1.9/classes/Range.html">Range</a></li>
          </ul>
        </div>
        <p>Коратка пра мэтады, каторыя прадстаўляюцца дыяпазонамі (поўны сьпіс і тлумачэньне даступныя па спасылцы зьлева):</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        # атрымаць першы(-я) элемэнт(-ы) дыяпазону:
        (1..5).begin                #=> 1
        (1..5).first                #=> 1
        (1..5).first(2)             #=> [1, 2]
        
        # атрымаць апошні(-я) элемэнт(-ы) дыяпазону:
        (1..5).end                  #=> 5
        (1..5).last                 #=> 5
        (1..5).last(2)              #=> [4, 5]
        
        # ці ўваходзіць значэньне ў дыяпазон:
        (1..5) === 3                #=> true
        ('A'..'Z').include?('a')    #=> false  (акрамя мэтаду include? можа ўжывацца яшчэ і member?)
        
        # перабор кожнага элемэнту:
        sum = 0
        (1..5).each do |i|
          sum += i
        end                         
        puts sum                    #=> 15
        
        # перабор кожнага n-га элемэнту:
        (1..5).step(2) do |i|
          print i.to_s + ' '
        end                         #=> 1 3 5        

        # пераўтварэньне ў масіў з выдаленьнем значэньняў па ўмове:
        (1..9).reject { |i| i < 5 } #=> [5, 6, 7, 8, 9]        
        ]]></script>
        
        <h2><a name="Types_Arrays">Масівы</a></h2>
        <p>Масівы прадстаўляецца шэрагам значэньняў, заключаных паміж прамымі дужкамі, і, падзеленых паміж сабой коскамі. Уключаюць у сябе дамешак <a href="#Types_Enumerable"><code class="class">Enumerable</code></a>.</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        [1, 2, 3]                         # масіў лічбаў 1, 2, 3
        ['coat', 'mittens', 'snowboard']  # масіў радкоў
        ]]></script>
        <p>Масіў не абавязкова павінен быць аднародным:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        [1, 'coat', 5, 7, 'snowboard']    # разнародны масіў
        ]]></script>
        
        <h2><a name="Types_Hashes">Хэшы</a></h2>
        <p>Хэшы можна параўнаць са слоўнікамі, у каторых кожнаму слову пастаўлена ў адпаведнасьць яго вызначэньне. Прадстаўляюцца шэрагам вызначэньняў, заключаных паміж фігурнымі дужкамі, і, падзеленых паміж сабой коскамі. Паміж словам і яго вызначэньнем стаяць знакі <code>=&gt;</code>. Уключаюць у сябе дамешак <a href="#Types_Enumerable"><code class="class">Enumerable</code></a>.</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        {'a' => 'aardvark', 'b' => 'badger'}
        ]]></script>
        <p>У адрозьненьне ад масіваў значэньні хэшаў утрымліваюцца <strong>не</strong>пасьлядоўна.</p>
        
        <h2><a name="Types_Regexp">Рэгулярныя выразы</a></h2>
        <p>Рэгулярныя выразы (<i>regexp</i>)&nbsp;&mdash; пасьлядоўнасьць сымбаляў, заключаных паміж слэшаў:</p>
        <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
        /ruby/, /[0-9]+/ ці /^\d{3}-\d{3}-\d{4}/
        ]]></script>
        <p>Яны прызначаны для хуткага пошуку словаў ці патэрнаў у тэксьце.</p>

      </section>


      
      <section>
        <h1><a name="Gems">Gems</a></h1>
        <div class="refs">
          <ul>
            <li><a href="http://rubygems.org/">Home</a></li>
            <li><a href="http://docs.rubygems.org/">Docs</a></li>
          </ul>
        </div>
        
        <h2><a name="Gems_DevKit">DevKit</a></h2>
        <div class="refs">
          <ul>
            <li><a href="http://rubyinstaller.org/add-ons/devkit/">Home</a></li>
            <li><a href="https://github.com/oneclick/rubyinstaller/wiki/development-kit/">Wiki</a></li>
          </ul>
        </div>
        <p>Большасьць гемаў даступны ў бінарным выглядзе і для іх усталёўкі дастаткова набраць <code>gem install &lt;GEM_NAME&gt;</code>. Але гэта тычыцца ня ўсіх гемаў. Некаторыя зь іх, так называемыя натыўныя, даступны толькі ў выглядзе зыходнікаў (напр. на C/C++) і для іх "зборкі" патрэбна пашырэньне да <i>Ruby</i> пад назвай <i>Development Kit</i> (скарочана <i>DevKit</i>).</p>

        <h3><a name="Gems_DevKit_install">Усталёўка</a></h3>
        <p>Па-першае спампоўваем архіў усталёўшчыка <code>DevKit-tdm-32-4.5.1-20101214-1400-sfx.exe</code> (ці больш актуальную вэрсію) на старонцы <a href="https://github.com/oneclick/rubyinstaller/downloads/">https://github.com/oneclick/rubyinstaller/downloads</a>.</p>
        <p>Запускаем спампаваны файл і пазначаем тэчку для распакоўкі, напр. <code>&lt;RUBY_HOME&gt;\devkit</code>.</p>
        <p>Адкрываем акно каманднага радку <code>cmd</code> і пераходзім у ім у пазначаную вышэй для распакоўкі тэчку.</p>
        <p>У акне каманднага радку пасьлядоўна запускаем наступныя каманды:</p>
        <script type="syntaxhighlighter" class="brush: text"><![CDATA[
        ruby dk.rb init
        ]]></script>
        <p>Вынік каторай будзе прыкладна такім:</p>
        <p><img alt="ruby dk.rb init" title="ruby dk.rb init" src="../images/devkit1.png"/></p>
        <p>Далей:</p>
        <script type="syntaxhighlighter" class="brush: text"><![CDATA[
        ruby dk.rb review
        ]]></script>
        <p>Вынік каторай будзе прыкладна такім:</p>
        <p><img alt="ruby dk.rb review" title="ruby dk.rb review" src="../images/devkit2.png"/></p>
        <p>На гэтым этапе трэба пераканацца, што ўсталёўшчык правільна падхапіў шлях да вашай <i>Ruby</i>-усталёўкі. Калі шлях ня правільны, тады трэба адпаведна падправіць файл <code>&lt;RUBY_HOME&gt;\devkit\config.yml</code>.</p>
        <p>Ну і напрыканцы непасрэдна ўсталёўка:</p>
        <script type="syntaxhighlighter" class="brush: text"><![CDATA[
        ruby dk.rb install
        ]]></script>
        <p>Вынік каторай будзе прыкладна такім:</p>
        <p><img alt="ruby dk.rb install" title="ruby dk.rb install" width="920px" src="../images/devkit3.png"/></p>
        
        <h3><a name="Gems_DevKit_Check">Праверка</a></h3>
        <p>Запусьціць усталёўку натыўнага гема і тым самым праверыць ці правільна ўсталяваўся <code>DevKit</code> можна наступным чынам:</p>
        <script type="syntaxhighlighter" class="brush: text"><![CDATA[
        gem install ruby-debug19 --platform=ruby
        ]]></script>
      </section>

      <footer>
        <div id="powered">
          <h5>Падзякі</h5>
          <p>Пры састаўленьні даведніка выкарыстоўваліся наступныя скрыпты, за якія аўтар выказвае свае падзякі іх аўтарам:
            <ul>
              <li><a href="http://jquery.com/">jQuery</a>&nbsp;&mdash; унівэрсальная JavaScript-бібліятэка</li>
              <li><a href="http://www.caodesigns.com/blog/free-stuff/jquery-active-menu-plugin-2.php">Active Menu</a>&nbsp;&mdash; дадатак да jQuery, каб пазначаць цяперашні разьдзел у каталёгу даведнікаў</li>
              <li><a href="http://xregexp.com/">XRegExp</a>&nbsp;&mdash; JavaScript-бібліятэка для рэгулярных выразаў (regexp)</li>
              <li><a href="http://www.mattkruse.com/javascript/mktree/">DHTML Tree</a>&nbsp;&mdash; скрыпт для пабудовы герархічнага дрэва разьдзелаў даведніка злева.</li>
              <li><a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a>&nbsp;&mdash; скрыпт для каляроўкі фрагмэнтаў коду пэўных моваў/скрыптоў.</li>
            </ul>
          </p>
        </div>
        <div id="copyright">
          <p>Copyright &copy; 2010-2011 <a href="http://www.yurtsevich.info">yurtsevich.info</a></p>
          <p>
            <a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/deed.be">
              <img src="http://i.creativecommons.org/l/by-nc/3.0/88x31.png"
                  style="border-style: none;" alt="Common Creatives. Attribution + Noncommercial (by-nc)" />
            </a>
          </p>
          <p><cite>Тэхнічны даведнік па Ruby</cite> публікуецца пад ліцензіяй <cite>Commons Creative Attribution-NonCommercial 3.0 Unported (CC BY-NC 3.0)</cite>. Вы вольны ў тым, як выкарыстоўваць гэтую працу, у тым ліку капіяваць, распаўсюджваць і зьмяняць яе на свой капыл. Але <strong>толькі ў некамэрцыйных мэтах</strong> і <strong>абавязкова з пазнакай <a href="http://www.yurtsevich.info/refs/rubyRef/index.html">крыніцы</a></strong> матэрыялу.</p>
        </div>
      </footer>
    </article>
  </div> <!--! end of #container -->


  <!-- Javascript at the bottom for fast page loading -->

  <!-- GetSatisfaction feedback button BEGIN -->
  <script type="text/javascript" charset="utf-8">
    var is_ssl = ("https:" == document.location.protocol);
    var asset_host = is_ssl ? "https://s3.amazonaws.com/getsatisfaction.com/" : "http://s3.amazonaws.com/getsatisfaction.com/";
    document.write(unescape("%3Cscript src='" + asset_host + "javascripts/feedback-v2.js' type='text/javascript'%3E%3C/script%3E"));
  </script>

  <script type="text/javascript" charset="utf-8">
    var feedback_widget_options = {};
  
    feedback_widget_options.display = "overlay";  
    feedback_widget_options.company = "yurtsevich";
    feedback_widget_options.placement = "right";
    feedback_widget_options.color = "#222";
    feedback_widget_options.style = "problem";
  
    var feedback_widget = new GSFN.feedback_widget(feedback_widget_options);
  </script>
  <!-- GetSatisfaction feedback button END -->

  <!-- Grab Google CDN's jQuery. fall back to local if necessary -->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="../js/libs/jquery-1.4.2.js"%3E%3C/script%3E'))</script>
    
  <script src="../js/mylibs/jquery.activeMenu.js"></script>
  <script>
    $(document).ready(function(){ 
      $('#main_index ul').activeMenu(); 
    }); 
  </script>

  <script src="../js/mylibs/mktree.js"></script>
  <script src="../js/mylibs/xregexp.js"></script>
  <script src="../js/mylibs/shCore.js"></script> 
  <script src="../js/mylibs/shAutoloader.js"></script>
  <script type="text/javascript">
    function path()
    {
      var args = arguments,
          result = []
          ;
       
      for(var i = 0; i < args.length; i++)
          result.push(args[i].replace('@', '../js/mylibs/'));
           
      return result
    };
 
    SyntaxHighlighter.autoloader.apply(null, path(
      'applescript            @shBrushAppleScript.js',
      'actionscript3 as3      @shBrushAS3.js',
      'bash shell             @shBrushBash.js',
      'coldfusion cf          @shBrushColdFusion.js',
      'cpp c                  @shBrushCpp.js',
      'c# c-sharp csharp      @shBrushCSharp.js',
      'css                    @shBrushCss.js',
      'delphi pascal          @shBrushDelphi.js',
      'diff patch pas         @shBrushDiff.js',
      'erl erlang             @shBrushErlang.js',
      'groovy                 @shBrushGroovy.js',
      'java                   @shBrushJava.js',
      'jfx javafx             @shBrushJavaFX.js',
      'js jscript javascript  @shBrushJScript.js',
      'perl pl                @shBrushPerl.js',
      'php                    @shBrushPhp.js',
      'text plain             @shBrushPlain.js',
      'py python              @shBrushPython.js',
      'ruby rails ror rb      @shBrushRuby.js',
      'sass scss              @shBrushSass.js',
      'scala                  @shBrushScala.js',
      'sql                    @shBrushSql.js',
      'vb vbnet               @shBrushVb.js',
      'xml xhtml xslt html    @shBrushXml.js'
    ));
    
    SyntaxHighlighter.defaults['toolbar'] = false;
    SyntaxHighlighter.all();
  </script>  
    
  <!-- scripts concatenated and minified via ant build script-->
  <script src="../js/plugins.js"></script>
  <script src="../js/script.js"></script>
  <!-- end concatenated and minified scripts-->
  
  
  <!--[if lt IE 7 ]>
    <script src="js/libs/dd_belatedpng.js"></script>
    <script> DD_belatedPNG.fix('img, .png_bg'); //fix any <img> or .png_bg background-images </script>
  <![endif]-->

  <!-- yui profiler and profileviewer - remove for production -->
  <script src="../js/profiling/yahoo-profiling.min.js"></script>
  <script src="../js/profiling/config.js"></script>
  <!-- end profiling code -->


  <!-- asynchronous google analytics: mathiasbynens.be/notes/async-analytics-snippet 
       change the UA-XXXXX-X to be your site's ID -->
  <script>
   var _gaq = [['_setAccount', 'UA-18077954-1'], ['_trackPageview']];
   (function(d, t) {
    var g = d.createElement(t),
        s = d.getElementsByTagName(t)[0];
    g.async = true;
    g.src = ('https:' == location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    s.parentNode.insertBefore(g, s);
   })(document, 'script');
  </script>
  
  <script src="http://static.getclicky.com/js" type="text/javascript"></script>
  <script type="text/javascript">clicky.init(17136);</script>
</body>
</html>